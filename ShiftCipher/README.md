# Portfolio: Shift Cipher (C++)

## Table of Contents
* [Introduction](#intro)
	- [Abstract](#abstact)
* [Installation](#install)
* [Quick Background](#quick-backgnd)
	* [Basics](#backgnd-basis)
+ [Design Decisions](#design-decisions)
	
<h2 id='intro'>Introduction</h2>
<h4>Author: Marcus Collins</h4>

<h3 id='abstract'>Abstract</h3>
This project aims to demonstrate basic facility with the C++ language and compilation to executables. Two executables are generated by default using the 
included Makefile. 
There are no expected users for this code/software, but installation
instructions are included below for reference and ease.

<h2 id="install">Installation</h2>
To compile the two executables, a C++ compiler with standard C++17 capability
required. All included libraries and headers are from the standard library.
A Linux environment is expected with a version of 'make' installed as well.
The <b>Makefile</b> does the compilation for the two executables (source code 
for each is located within the <b>source</b> directory).

<h2 id="quick-backgnd">Quick Background<h2>
<h3>Reference: <a href="https://www.cryptography-textbook.com/">Understanding Cryptography</a></h3>

<h3 id="backgnd-basics">Basics</h3>
Readers interested in a more thorough introduction to shift ciphers
are encouraged to read the above reference (Chapter 1). 

A Shift Cipher is a text enciphering scheme that takes a finite-sized 
alphabet (assumed English for this demo project) and shifts each 
letter from that alphabet by a fixed amount either forwards or
backwards. If a letter is shifted off either end of the letter space 
(think in terms of a list with indices), then a circular-shift occurs
where that letter reappears on the other end of the list. This can be
described mathematically with the modulus operation or demonstrated 
with a small diagram.
> N = 26 (number of letters in English alphabet ignoring case) <br>
> k = shift amount <br>
> x = letter from alphabet <br>
> y = letter from shifted alphabet <br>
> `e(x) = x + k mod N == y`

> | A | B | C | ... | Y | Z | <br>
> | - | - | A | ... | W | X |  Y  Z  (with shift of 2) <br>
> | Y | Z | A | ... | W | X |  (final result of shift) <br>
> this would result in any '**A**' in the original text being replaced
> by '**Y**' in the enciphered text (and so on).

> To decipher the resulting text is straightforward when the
> shift amount is known (and the construction of the alphabet list 
> needs to be known as well - meaning: is a mixed-case alphabet 
> being used). <br>
> `d(y) = d(e(x)) = y - k mod N`

Again, this is not meant to be a full explanation of enciphering or 
encryption, but hopefully the intended functionality of the demo 
programs is more apparent.

<h2 id="design-decisions">Design Decisions</h2>
<ol>
<li> The input text to be enciphered is assumed to be a mix of
	<ul>
	<li>lowercase [English] letters</li>
	<li>uppercase [English] letters</li>
	<li>numbers</li>
	<li>punctuation</li>
	</ul>
</li>
<li>By <b><i>default</i></b>, both numbers and punctuation are **NOT** included in the shift cipher. <br>A flag can be used to encipher the both of them also.</li>
</ol>


